# Budgets_django

Согласно Вашего ТЗ посторен модуль loadata.py с функцией load_data_from(url, options) для загрузки данных с удаленного источника данных, принемающей url-адрес источника и дополнительные параметры загрузки в виде options = {'params':{'plist': [], 'pcurent': {}, 'pdefault': {}}, 'fields': {}, 'relations': {}},
где

словарь params = {'plist': [], 'pcurent': {}, 'pdefault': {}} суть прараметры загрузки позволяющие настроить фильтрацию по API источника данных и содержащий список всех необходимых атрибутов plist, словарь текущих настроек получаемых через get-запрос или иным способом pcurent и словарь настроек по умолчанию  pdefault задаваемый в модели;

словарь fields содержащий соответствие полей таблицы БД с атрибутами возвращемыми в ответе источника данных;

словаарь relations содержащий соответствие полей ForeignKey с атрибутами указывающими на иные записи во внешнем источнике данных,

и возвращает список содежащий словари формата response = {'fields': {}, 'relations': {}}

Это позволяет гибко настраивать загрузчик под различные данные передоваемые внешним источником. В данном случае настройка параметров загрузчика производится в моделях таблиц БД. Для обработки запросов к БД каждая модель предоставляет пользовательские Manager и QuerySet с функциями update_budget и update_ppo (для модели Budget и модели PPO_Budget соответственно), где обрабатывается ответ от внешнего источника данных. Для создания рекурсивных ссылок в модели Budget используется рекурсивная функция _get_parent позволяющая отыскать родителя текушей записи в БД либо запросить его из внешнего источника, причем при наличии у родителя собственного родителя поиск продолжается по нему, и так далее, до тех пор пока не найдется запись которая не на что не ссылается, либо ссылается на саму себя, либо уже присутствует в БД. В нетипичных случаях, как-то, одна запись из внешнего источника ссылается на другую запись которая в свою очередь отсутствует, загрузчик возвращает список словарей формата response = {'fields': None, 'relations': None}, поэтому эти случаи необходимо отдельно обработать в запрашивающей эти данные модели. В данном решении при наступлении нетипичного случая модель создает фиктивную запись с указением кода и именем name = "Бюджет необнаружен", а тип фиктивного бютжета budgettype = "Неопределённый". Запросы на обновление БД с параметрами фильтрации, в данном решеннии, передаются через адресную строку в админке restAPI имметируя внешний get-запрос. Формат запроса соответствует запросу по API соответствующего внешнего источника, за исключением параметра update=True, позволяющему включать обновление ранее загруженных данных. Эти параметры описываются в списке plist словаря params входящего в список options.

P.S. Прошу учесть то обстоятельство, что я ранее не пользовался фреймворками Django и DRF и зто обстоятельство повлияло на срок решения задачи. К тому же наличие во внешнем источнике данных непроверенных запесей и различного рода ошибок, а также низкая скорость интернет соединения привело к увеличению времени на решение. В итоге из-за ооооооооочнеь долгой загрузки данных из внешнего источника мне не удалось загрузить все более чем 22000 записей бюджетов, но настройки загрузчика позволяют загружать данные по регионам например как было сделано в моем случае.
